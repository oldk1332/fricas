)abbrev domain TOKENISE Tokeniser
++ Author: Martin Baker
++ Date Created: April 2014
++ Date Last Updated: April 2014
++ Description:
++   This takes the input string and converts it to a list of tokens.
++
++ To do:
++  * need to be able to split non-alphanumeric symbols
++  for example a=(b+c)*(d+e) only works if we put space next to *
++  * floats not yet handled correctly
++  for example 3e-5 would not work correctly
++
++   I have put specific information about this tokeniser here:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/system/interpreter/tokeniser/
++   I have put more general information about running this code here:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/system/interpreter/

Tokeniser : Exports == Implementation where
  NNI==> NonNegativeInteger
  SY==> Symbol
  TOKENTYPE ==> Symbol
    ++ valid token types are:
    ++ id: Symbol
    ++ key: Symbol
    ++ integer: Symbol
    ++ rinteger: Symbol
    ++ float: Symbol
    ++ string: Symbol
    ++ comment: Symbol
    ++ negcomment: Symbol
    ++ error: Symbol
    ++ spaces: Symbol
  TOKEN ==> Record(tt:TOKENTYPE,tokVal:Union(strng:String,symbl:Symbol))
    ++ holds a single token from scanner
  KEYS ==> List Record(keya:String,keyb:Symbol,keyc:NNI,keyd:NNI,keye:NNI,keyf:NNI)
    ++ Table of keywords and their precidences. Contains:
    ++ keya:String - name of keyword
    ++ keyb:Symbol - symbolic identifier for keyword
    ++ keyc:NNI - left precidence for binary operations
    ++ keyd:NNI - right precidence for binary operations
    ++ keye:NNI - left precidence for unary operations
    ++ keyf:NNI - right precidence for unary operations
    ++ perhaps this should be hash table?
    ++ can be optimised later if needed

  Exports == with

    spadTokenise:(s:String,param:Interpret) -> %
      ++ constructor to put string into tokeniser
    getAll:(n: %) -> List TOKEN
      ++ gets complete list of tokens
    next:(n: %) -> TOKEN
      ++ gets but not consume next token
    consume!:(n: %) -> TOKEN
      ++ consume next token
    consumeNonSpace!:(n: %) -> TOKEN
      ++ consume next token stepping over spaces
    more?:(n: %) -> Boolean
      ++ true if has more
    hasError?:(toks:%) -> Boolean
      ++ true if there is an error anywhere in the list
    coerce: (n: %) -> OutputForm
      ++ output
  Implementation ==> add

    import from Interpret

    Rep := Record (TokLst:List TOKEN,Ptr:NNI)
      ++ list of tokens and pointer to this list.

    -- gets complete list of tokens
    getAll(n: %):List(TOKEN) ==
      (n.TokLst) pretend List(TOKEN)

    -- true if there is an error anywhere in the list
    hasError?(toks:%):Boolean ==
      -- tl = current list of tokens
      tl := toks.TokLst
      for t in tl repeat
        if t.tt = "error"::Symbol then return true
      false
        

    -- gets but not consume next token
    next(n: %):TOKEN ==
      -- p = pointer to next token
      p := n.Ptr
      -- tl = current list of tokens
      tl := n.TokLst
      if p > (#tl) then return ["error"::Symbol,["more expected"]]
      ret:TOKEN := tl.p

    -- consume next token
    consume!(n: %):TOKEN ==
      p := n.Ptr
      tl := n.TokLst
      if p > (#tl) then return ["error"::Symbol,["more expected"]]
      ret:TOKEN := tl.p
      n.Ptr := p+1
      ret

    -- consume next token (stepping over spaces)
    consumeNonSpace!(n: %):TOKEN ==
      p := n.Ptr
      tl := n.TokLst
      if p > (#tl) then return ["error"::Symbol,["more expected"]]
      ret:TOKEN := tl.p
      if ret.tt = "error"::Symbol then
        p := p+1
        if p > (#tl) then return ["error"::Symbol,["more expected"]]
        ret:TOKEN := tl.p
      n.Ptr := p+1
      ret

    -- gets gets and consume next token
    more?(n: %):Boolean ==
      p := n.Ptr
      tl := n.TokLst
      (p > (#tl))

    -- used by spadTokenise to make a symbolic token
    makeSymToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):TOKEN ==
      t:TOKENTYPE := "id"::Symbol
      subChars:List(Character) := [cl.x for x in (startIndex..(endIndex))]
      s:String := construct(subChars)
      for key in keys repeat
        if s = key.keya then return ["key"::Symbol,[key.keyb]]
      [t,[s]]

    -- used by spadTokenise to make a integer token
    makeIntToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):TOKEN ==
      t:TOKENTYPE := "integer"::Symbol
      subChars:List(Character) := [cl.x for x in (startIndex..(endIndex))]
      s:String := construct(subChars)
      [t,[s]]

    -- used by spadTokenise to make a float token
    makeFloatToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):TOKEN ==
      t:TOKENTYPE := "id"::Symbol
      subChars:List(Character) := [cl.x for x in (startIndex..(endIndex))]
      s:String := construct(subChars)
      [t,[s]]

    -- used by makeOperatorTokens
    lookupOperatorToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):TOKEN ==
      t:TOKENTYPE := "error"::Symbol
      subChars:List(Character) := [cl.x for x in (startIndex..(endIndex))]
      s:String := construct(subChars)
      --print(hconcat([outputForm("lookupOperatorToken s="),outputForm(s)])$OutputForm)
      for key in keys repeat
        if s = key.keya then return ["key"::Symbol,[key.keyb]]
      [t,[s]]

    -- used by spadTokenise to make operator tokens
    -- first try to match whole input to keywords, if that does not
    -- work then, try splitting input. For instance, imagine we have
    -- a line like:
    -- a:=-3
    -- then this function would be called with ':=-' as its input
    -- which does not match a keyword so we try spitting it.
    -- ':' and '=-' don't both match so we try:
    -- ':=' and '-' which do both match.
    makeOperatorToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):List(TOKEN) ==
      -- first check if we can match whole thing
      candidateToken:TOKEN := lookupOperatorToken(cl,startIndex,endIndex,keys)
      if candidateToken.tt ~= "error"::Symbol then
        return [candidateToken]
      -- no match found for whole input so try splitting
      -- first make sure it is long enough to split
      if (endIndex - startIndex) < 1 then return [["error"::Symbol,["no match"]]]
      for midIndex in startIndex..endIndex repeat
        tokenA:TOKEN := lookupOperatorToken(cl,startIndex,midIndex,keys)
        tokenB:TOKEN := lookupOperatorToken(cl,midIndex+1,endIndex,keys)
        if (tokenA.tt ~= "error"::Symbol) and (tokenB.tt ~= "error"::Symbol) then
          return [tokenA,tokenB]
      [["error"::Symbol,["no match"]]]

    -- used by spadTokenise to make a space token
    makeSpaceToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):TOKEN ==
      t:TOKENTYPE := "space"::Symbol
      subChars:List(Character) := [cl.x for x in (startIndex..(endIndex))]
      s:String := construct(subChars)
      [t,[s]]

    -- used by spadTokenise to make a string token
    makeStringToken(cl:List Character,startIndex:Integer,endIndex:Integer,keys:KEYS):TOKEN ==
      t:TOKENTYPE := "string"::Symbol
      subChars:List(Character) := [cl.x for x in (startIndex..(endIndex))]
      s:String := construct(subChars)
      [t,[s]]

    lookupStateTable(current:SY,inp:SY):SY ==
      -- 'stateTable' gives next state for possible inputs.
      -- This table is explained more fully here:
      -- http://www.euclideanspace.com/prog/scratchpad/mycode/system/interpreter/tokeniser/
      stateTable:List List Symbol := [_
        ["space"::SY,"string"::SY,"sym"::SY,"integ"::SY,"op"::SY],_
        ["space"::SY,"string"::SY,"sym"::SY,"integ"::SY,"op"::SY],_
        ["string"::SY,"init"::SY,"string"::SY,"string"::SY,"string"::SY],_
        ["space"::SY,"string"::SY,"sym"::SY,"sym"::SY,"op"::SY],_
        ["space"::SY,"string"::SY,"sym"::SY,"integ"::SY,"op"::SY],_
        ["space"::SY,"string"::SY,"sym"::SY,"float"::SY,"op"::SY],_
        ["space"::SY,"string"::SY,"sym"::SY,"integ"::SY,"op"::SY],_
        ["comment"::SY,"comment"::SY,"comment"::SY,"comment"::SY,"comment"::SY]]
      inputStates:List Symbol := ["init"::SY,"space"::SY,"string"::SY,"sym"::SY,_
            "integ"::SY,"float"::SY,"op"::SY,"comment"::SY]
      inputChar:List Symbol := ["space"::SY,"quote"::SY,"alpha"::SY,_
             "numeric"::SY,"other"::SY]
      stateIn:Integer := position(current,inputStates,1)$List(Symbol)
      --print(hconcat([outputForm("stateIn:"),outputForm(stateIn),_
      --              outputForm(" current"),outputForm(current)])$OutputForm)
      if stateIn < 1 then return "error"::SY
      charIn:Integer := position(inp,inputChar,1)$List(Symbol)
      --print(hconcat([outputForm("charIn:"),outputForm(charIn)])$OutputForm)
      if charIn < 1 then return "error"::SY
      --print(hconcat([outputForm("lookup:"),outputForm((stateTable.stateIn).charIn)])$OutputForm)
      (stateTable.stateIn).charIn

    -- constructor to put string into tokeniser
    spadTokenise(s:String,param:Interpret):% ==
      -- precidences from nud table
      -- from s-parser.boot
      keys:KEYS := getKeys(param)
      -- res holds result (tokens generated) so far,
      res:List(TOKEN) := nil()$List(TOKEN)
      -- input string as list of characters
      cl:List Character := entries(s)
      -- current token type being read
      ttCur:TOKENTYPE := "null"::Symbol
      startIndex:NNI := 1
      -- state - acts like a state machine as we step through the line
      -- valid states are:
      -- 'init' - initial state at start of line or after a space
      -- 'space' - after a space
      -- 'sym' - first character is alphbetic then alphbetic or
      --         numeric but not operator or punctation
      -- 'integ' - purely numeric ('-' prefix not part of token)
      -- 'float' - first character is numeric then numeric or
      --           '.' or 'e' or 'E'
      -- 'op' - reading operator or punctation but not space
      --        alphbetic or numeric
      state:SY := "init"::SY
      inp:SY
      -- step through line one character at a time.
      for c in cl for i in 1..(#cl) repeat
        --inputChar:List Symbol := ["space"::SY,"quote"::SY,"alpha"::SY,_
        --     "numeric"::SY,"other"::SY]
        inp := "other"::SY
        if c=space() then inp := "space"::SY
        if c=quote() then inp := "quote"::SY
        if alphabetic?(c) then inp := "alpha"::SY
        if digit?(c) then inp := "numeric"::SY
        newState:SY := lookupStateTable(state,inp)
        --print(hconcat([outputForm("spadTokenise:"),outputForm(newState)])$OutputForm)
        if newState~=state then
          if state="sym"::SY then
            res := concat(res,makeSymToken(cl,startIndex,i-1,keys))
          if state="integ"::SY then
            res := concat(res,makeIntToken(cl,startIndex,i-1,keys))
          if state="float"::SY then
            res := concat(res,makeFloatToken(cl,startIndex,i-1,keys))
          if state="op"::SY then
            res := concat(res,makeOperatorToken(cl,startIndex,i-1,keys))
          if state="space"::SY then
            res := concat(res,makeSpaceToken(cl,startIndex,i-1,keys))
          if state="string"::SY then
            res := concat(res,makeStringToken(cl,startIndex,i-1,keys))
          startIndex := i
        state := newState
      -- write the last token
      if state="init"::SY then
        return [res,1]
      if state="sym"::SY then
        res := concat(res,makeSymToken(cl,startIndex,#cl,keys))
      if state="integ"::SY then
        res := concat(res,makeIntToken(cl,startIndex,#cl,keys))
      if state="float"::SY then
        res := concat(res,makeFloatToken(cl,startIndex,#cl,keys))
      if state="op"::SY then
        res := concat(res,makeOperatorToken(cl,startIndex,#cl,keys))
      if state="space"::SY then
        res := concat(res,makeSpaceToken(cl,startIndex,#cl,keys))
      if state="string"::SY then
        res := concat(res,makeStringToken(cl,startIndex,#cl,keys))
      [res,1]
        
    coerce(n: %):OutputForm ==
      toks:List(OutputForm) := nil()$List(OutputForm)
      for v in n.TokLst repeat
        tok:OutputForm := hconcat([(v.tt)::OutputForm,_
          "="::OutputForm,_
          (v.tokVal)::OutputForm_
          ])
        toks := concat(toks,tok)$List(OutputForm)
      bracket(toks)
@

)abbrev domain PARSE Parser
++ Author: Martin Baker
++ Date Created: April 2014
++ Date Last Updated: April 2014
++ Description:
++   This takes a list of tokens and converts it to a tree structure
++   containing values it also has code for inferring types.
++
++
++   I have put specific information about this parser here:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/system/interpreter/parser/
++   I have put more general information about running this code here:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/system/interpreter/

Parser : Exports == Implementation where
  NNI==> NonNegativeInteger
  SY==> Symbol
  TOKENTYPE ==> Symbol
    ++ valid token types are:
    ++ id: Symbol
    ++ key: Symbol
    ++ integer: Symbol
    ++ rinteger: Symbol
    ++ float: Symbol
    ++ string: Symbol
    ++ comment: Symbol
    ++ negcomment: Symbol
    ++ error: Symbol
    ++ spaces: Symbol
  TOKEN ==> Record(tt:TOKENTYPE,tokVal:Union(strng:String,symbl:Symbol))
    ++ holds a single token from scanner
  NODETYPE ==> Symbol
    ++ valid node types are:
    ++fn: Symbol - function, including unary and binary operations
    ++             subtree may contain zero or n parameters
    ++var: Symbol - variable name represented by a string
    ++lit: Symbol - literal values, such as a number, held in
    ++              a string
  NODE ==> Record(nt:NODETYPE,spadType:MType,nodeVal:Union(strng:String,symbl:Symbol))
    ++ holds a single node in a parse tree.
    ++ This has both type and value information.
    ++ Initially nt holds an approximate type but later this needs
    ++ be matched to a full SPAD type held in spadType.
  KEYS ==> List Record(keya:String,keyb:Symbol,keyc:NNI,keyd:NNI,keye:NNI,keyf:NNI)
    ++ Table of keywords and their precidences. Contains:
    ++ keya:String - name of keyword
    ++ keyb:Symbol - symbolic identifier for keyword
    ++ keyc:NNI - left precidence for binary operations
    ++ keyd:NNI - right precidence for binary operations
    ++ keye:NNI - left precidence for unary operations
    ++ keyf:NNI - right precidence for unary operations
    ++ perhaps this should be hash table?
    ++ can be optimised later if needed

  Exports == with

    spadParse:(tl:Tokeniser,param:Interpret) -> %
      ++ constructor to construct tree from token list
    spadParse1:(tl:Tokeniser,p:NNI,param:Interpret) -> %
      ++ only used by spadParse and subnode
      ++ export this because its recursive
    hasError?:(tr:%,guard:NNI) -> Boolean
      ++ true if there is an error anywhere in the tree
    typeMatch:(untyped:%,param:Interpret) -> %
      ++ try to fill in type values
      ++ traverse tree trying to match rules and calling itself
      ++ recursivly
--    coerce: (n: %) -> OutputForm
      ++ output
      ++ tree can already be coerced to outputForm so this is not needed
  Implementation ==> add

    import from Interpret
    import from MType

    Rep := Tree(NODE)
      ++ tree structure.

    isError?(t:NODE):Boolean ==
       t.nt = "error"::SY

    -- true if there is an error anywhere in the tree
    hasError?(tr:%,guard:NNI):Boolean ==
      tr1:Tree(NODE) := tr pretend Tree(NODE)
--      mathprint("hasError? called:")$Lisp
--      print(tr1::OutputForm)
      if guard>20 then return true
      if cyclic?(tr1)$Tree(NODE) then return true
      if empty?(tr1)$Tree(NODE) then return false
      if leaf?(tr1)$Tree(NODE) then
        v:NODE := value(tr1)$Tree(NODE)
        return isError?(v)
      nds:List(Tree(NODE)) := children(tr1)$Tree(NODE)
      if #nds < 1 then return false
--      mathprint("hasError? nds:=")$Lisp
--      print(nds::OutputForm)
      for nd in nds repeat
--        mathprint("hasError? nd:=")$Lisp
--        print(nd::OutputForm)
        if hasError?(nd,guard+1) then return true
      false

    -- check for given key, such as PLUS
    isKey?(t:TOKEN,s:SY):Boolean ==
      if t.tt ~= "key"::Symbol then return false
      if (t.tokVal) case symbl then
        --print(hconcat([outputForm("isKey?"),t::OutputForm,_
        --  outputForm(" s="),outputForm(s),_
        --  outputForm(" tokVal="),outputForm((t.tokVal).symbl)])$OutputForm)
        return ((t.tokVal).symbl)=s
      false

    -- returns true if given token represents a binary operation
    -- this is determined by the precidence values in the keyword
    -- table being non-zero
    binary?(t:TOKEN,keys:KEYS):Boolean ==
      --print(hconcat([outputForm("binary?"),t::OutputForm])$OutputForm)
      if (t.tokVal) case symbl then
        sy:Symbol := (t.tokVal).symbl
        for key in keys repeat
          if sy = key.keyb then
            if key.keyc > 0 then return true
            if key.keyd > 0 then return true
            return false
      false

    -- returns true if given token represents a unary operation
    -- (one parameter)
    -- this is determined by the precidence values in the keyword
    -- table being non-zero
    unary?(t:TOKEN,keys:KEYS):Boolean ==
      if (t.tokVal) case symbl then
        sy:Symbol := (t.tokVal).symbl
        for key in keys repeat
          if sy = key.keyb then
            if key.keye > 0 then return true
            if key.keyf > 0 then return true
            return false
      false

    -- returns true if given token represents a leaf
    -- that is: not an operation with parameters
    isLeaf?(t:TOKEN):Boolean ==
      --print(hconcat([outputForm("isLeaf?"),t::OutputForm])$OutputForm)
      if t.tt = "id"::Symbol then return true
      if t.tt = "integer"::Symbol then return true
      if t.tt = "rinteger"::Symbol then return true
      if t.tt = "string"::Symbol then return true
      if t.tt = "comment"::Symbol then return true
      if t.tt = "negcomment"::Symbol then return true
      if t.tt = "error"::Symbol then return true
      --print(hconcat([outputForm("isLeaf? false")])$OutputForm)
      false

    leftPrec(t:TOKEN,keys:KEYS):NNI ==
      if (t.tokVal) case symbl then
        sy:Symbol := (t.tokVal).symbl
        for key in keys repeat
          if sy = key.keyb then
            --print(hconcat([outputForm("leftPrec: token="),t::OutputForm,_
            --     outputForm(" sy="),outputForm(sy),_
            --     outputForm(" pres="),outputForm(key.keyc)])$OutputForm)
            return key.keyc
      0

    rightPrec(t:TOKEN,keys:KEYS):NNI ==
      if (t.tokVal) case symbl then
        sy:Symbol := (t.tokVal).symbl
        for key in keys repeat
          if sy = key.keyb then
            --print(hconcat([outputForm("rightPrec: token="),t::OutputForm,_
            --     outputForm(" sy="),outputForm(sy),_
            --     outputForm(" pres="),outputForm(key.keyd)])$OutputForm)
            return key.keyd
      0

    -- constructor for a function node
    parseTreeFunction(t:TOKEN,params:List(%)):% ==
      val:Union(strng:String,symbl:Symbol) := t.tokVal
      pars:List(Tree(NODE)) := params pretend List(Tree(NODE))
      n:NODE := ["fn"::SY,0$MType,val]
      tree(n,pars)$Tree(NODE)

    -- constructor for a variable node
    parseTreeVar(t:TOKEN):% ==
      val:Union(strng:String,symbl:Symbol) := t.tokVal
      n:NODE := ["var"::SY,typeConstruct("Symbol"::Symbol),val]
      tree(n)$Tree(NODE)

    -- constructor for a literal node
    parseTreeLiteral(t:TOKEN):% ==
      val:Union(strng:String,symbl:Symbol) := t.tokVal
      n:NODE := ["lit"::SY,typeConstruct("NonNegativeInteger"::Symbol),val]
      tree(n)$Tree(NODE)

    -- change the ID of root node
--    changeID!(tr:%,oldID:SY,newID:SY):Void ==
--      node:NODE := value(tr pretend Tree(NODE))
--      if (node.nodeVal).symbl ~= oldID then return void()
--      node.nodeVal := [newID]
--      void()

    -- this holds type matching rules for unary functions
    unaryRules(outKey:Symbol,inType:MType):MType ==
      if outKey="MINUS"::SY and_
        inType=typeConstruct("NonNegativeInteger"::Symbol) then
          return typeConstruct("Integer"::SY)
      if outKey="MINUS"::SY and_
        inType=typeConstruct("Integer"::SY) then
          return typeConstruct("Integer"::SY)
      if outKey="MINUS"::SY and_
        inType=typeConstruct("Symbol"::SY) then
          return typeConstruct("Polynomial"::SY,[typeConstruct("Integer"::SY)])
      0$MType

    -- try to fill in type values
    -- traverse tree trying to match rules and calling itself
    -- recursivly
    typeMatch(untyped:%,param:Interpret):% ==
      tr1:Tree(NODE) := untyped pretend Tree(NODE)
      if cyclic?(tr1)$Tree(NODE) then return untyped
      if empty?(tr1)$Tree(NODE) then return untyped
      if leaf?(tr1)$Tree(NODE) then
        v:NODE := value(tr1)$Tree(NODE)
        return untyped
      nds:List(Tree(NODE)) := children(tr1)$Tree(NODE)
      if #nds < 1 then return untyped
      if #nds = 1 then
        -- apply unary rules
        u:NODE := value(nds.1)$Tree(NODE)
        spadt:MType := u.spadType
        v:NODE := value(tr1)$Tree(NODE)
        if (v.nodeVal) case symbl then
          sy:Symbol := (v.nodeVal).symbl
          res:MType := unaryRules(sy,spadt)
          newNode:NODE := [v.nt,res,v.nodeVal]
          setvalue!(untyped,newNode)
        return untyped
      for nd in nds repeat
        untyped
      untyped

    -- parse a function starting with an ID followed by bracketed
    -- parameters 
    -- tl - tokeniser pointing to parameters
    -- n - ID representing function name
    parseFunction(tl:Tokeniser,n:TOKEN,param:Interpret):% ==
      --print(hconcat([outputForm("parseFunction start: n="),n::OutputForm_
      --              ])$OutputForm)
      res:Tree(NODE) := tree(["error"::Symbol,0$MType,["invalid function parameters"]])
      pars:List(%) := empty()$List(%)
      m:TOKEN := next(tl)
      if not isKey?(m,"OParen"::SY) then return res
      m := consumeNonSpace!(tl)
      m:=next(tl)
      if isKey?(m,"CParen"::SY) then
        -- function with no parameters
        m := consumeNonSpace!(tl)
        return parseTreeFunction(n,pars)
      -- read parameters, if there are multiple parameters
      -- they will be put in a comma node
      par:% := spadParse1(tl,0,param)
      par2:Tree(NODE) := par pretend Tree(NODE)
      node:NODE := value(par2)
      if (node.nodeVal) case symbl
        then 
          if (node.nodeVal).symbl = "COMMA"::SY
            then
              pars2:List(Tree(NODE)) := children(par2)$Tree(NODE)
              pars := pars2 pretend List(%)
            else pars := [par]
        else pars := [par]
      m := consumeNonSpace!(tl)
      parseTreeFunction(n,pars)

    -- read a single term which may be either:
    -- A literal value
    -- A unary operation
    -- A bracketed value
    -- A function call
    subNode(tl:Tokeniser,param:Interpret):% ==
      res:Tree(NODE) := tree(["error"::Symbol,0$MType,["invalid token"]])
      n:TOKEN := next(tl)
--      mathprint("subNode token:")$Lisp
--      print(bracket([n::OutputForm]))
      if unary?(n,getKeys(param)) then
        m:TOKEN := consumeNonSpace!(tl)
        q:NNI := leftPrec(n,getKeys(param))
        leftOperand:Tree(NODE) := spadParse1(tl,q,param) pretend Tree(NODE)
        return parseTreeFunction(n,[leftOperand])
        --return tree(n,[leftOperand])$Tree(NODE)
      -- bracketed term does not need to be a node, we can
      -- just save its contents as a branch
      if isKey?(n,"OParen"::SY) then
        m:TOKEN := consumeNonSpace!(tl)
--        mathprint("subNode m=")$Lisp
--        print(bracket([m::OutputForm]))
--        leftOperand:Tree(TOKEN) := spadParse1(tl,0,param) pretend Tree(TOKEN)
--        res:= tree(n,[leftOperand])$Tree(TOKEN)
        res:= spadParse1(tl,0,param) pretend Tree(NODE)
        -- consume opening bracket
        m2:TOKEN := consumeNonSpace!(tl)
--        mathprint("subNode m2=")$Lisp
--        print(bracket([m2::OutputForm]))
        if not isKey?(m2,"CParen"::SY) then
          leftOperand:Tree(NODE) := tree(["error"::Symbol,0$MType,["mismatch brackets"]])
          res:= parseTreeFunction(n,[leftOperand]) pretend Tree(NODE)
        -- consume closing bracket
        m2:TOKEN := consumeNonSpace!(tl)
        return res
      -- check for variable name or function call
      if n.tt = "id"::Symbol then
        m:TOKEN := consumeNonSpace!(tl)
        m:=next(tl)
        -- check for function call
        if isKey?(m,"OParen"::SY) then
          return parseFunction(tl,n,param)
        -- otherwise return ID
        return parseTreeVar(n)
      -- check for other type of leaf node such as some type
      -- of literal value.
      if isLeaf?(n) then
        m:TOKEN := consumeNonSpace!(tl)
        return parseTreeLiteral(n)
      consumeNonSpace!(tl)
      res

    -- construct tree from token list
    -- tl is token stream
    -- p is current precidence
    spadParse1(tl:Tokeniser,p:NNI,param:Interpret):% ==
      res:Tree(NODE) := subNode(tl,param) pretend Tree(NODE)
      n:TOKEN := next(tl)
      --print(hconcat([outputForm("spadParse1 start: n="),n::OutputForm,_
      --              outputForm(" res="),res::OutputForm,_
      --              outputForm(" leftPrec="),leftPrec(n,getKeys(param))::OutputForm,_
      --              outputForm(" p="),p::OutputForm,_
      --              outputForm(" binary"),binary?(n,getKeys(param))::OutputForm])$OutputForm)
      -- eat any binary ops unless precidence is less
      -- at lowest level this is always called with p=0
      -- so leftPrec(n,getKeys(param)) >= p will always be true at lowest
      -- level so no binary is ever left dangling
      while binary?(n,getKeys(param)) and leftPrec(n,getKeys(param)) >= p repeat
        --print(hconcat([outputForm("spadParse1 startloop: n="),n::OutputForm,_
        --            outputForm(" res="),res::OutputForm,_
        --            outputForm(" leftPrec="),leftPrec(n,getKeys(param))::OutputForm,_
        --            outputForm(" p="),p::OutputForm,_
        --            outputForm(" binary"),binary?(n,getKeys(param))::OutputForm])$OutputForm)
        consumeNonSpace!(tl)
        ql:NNI := leftPrec(n,getKeys(param))
        qr:NNI := rightPrec(n,getKeys(param))
        rightOperand:Tree(NODE) := spadParse1(tl,ql,param) pretend Tree(NODE)
        if hasError?(rightOperand,0) then
--          mathprint("spadParse1 error:")$Lisp
--          n:= next(tl)
--          print(bracket([n::OutputForm,leftPrec(n,getKeys(param))::OutputForm,p::OutputForm,_
--            rightOperand::OutputForm]))
--          return tree(n,[copy(res),0$MType,rightOperand])$Tree(NODE)
          return parseTreeFunction(n,[copy(res),rightOperand])
        res := parseTreeFunction(n,[copy(res),rightOperand]) pretend Tree(NODE)
        n:= next(tl)
      --mathprint("spadParse1 end:")$Lisp
      --print(bracket([n::OutputForm,leftPrec(n,getKeys(param))::OutputForm,p::OutputForm,_
      --  binary?(n,getKeys(param))::OutputForm]))
      res

    -- constructor to construct tree from token list
    spadParse(tl:Tokeniser,param:Interpret):% ==
      spadParse1(tl,0,param)

-- tree can already be coerced to outputForm so this is not needed
--    coerce(n: %):OutputForm ==
--      outputForm("test")
--      n::OutputForm
@

)abbrev domain INTER Interpret
++ Author: Martin Baker
++ Date Created: April 2014
++ Date Last Updated: April 2014
++ Description:
++   This is an experiment to see how much of the FriCAS
++   interpreter that I can write using SPAD code.
++   Currently the interpreter is written in 'boot' code. For
++   example in int-top.boot, server.boot, i-toplev.boot
++   i-syscmd.boot and many others.
++
++   Boot code is poorly documented and loosly typed. There
++   would be lots of advantages if boot code were removed.
++
++   I have made this a domain so that it can hold parameters
++   which would otherwise be global parameters in boot code.
++
++   When the constructor 'spadInterpret' is called it sets up
++   the parameters and then goes into the main interpreter loop
++   reading lines and then acting on them.
++
++   To start with the interpreter loop will just call the 
++   existing lisp functions. The plan is to gradually implement
++   more of these functions in high level code.
++
++   I have put information about running this code here:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/system/interpreter/
++   The original interpreter is undocumented so I'm trying to
++   bootstrap my understanding by working out what I can here:
++ http://www.euclideanspace.com/prog/scratchpad/internals/interpreter/

Interpret : Exports == Implementation where
  NNI==> NonNegativeInteger
  SY==> Symbol
  TOKENTYPE ==> Symbol
    ++ valid token types are:
    ++ id: Symbol
    ++ key: Symbol
    ++ integer: Symbol
    ++ rinteger: Symbol
    ++ float: Symbol
    ++ string: Symbol
    ++ comment: Symbol
    ++ negcomment: Symbol
    ++ error: Symbol
    ++ spaces: Symbol
  TOKEN ==> Record(tt:TOKENTYPE,tokVal:Union(strng:String,symbl:Symbol))
    ++ holds a single token from scanner
  NODETYPE ==> Symbol
    ++ valid node types are:
    ++fn: Symbol - function, including unary and binary operations
    ++             subtree may contain zero or n parameters
    ++var: Symbol - variable name represented by a string
    ++lit: Symbol - literal values, such as a number, held in
    ++              a string
  NODE ==> Record(nt:NODETYPE,spadType:MType,nodeVal:Union(strng:String,symbl:Symbol))
    ++ holds a single node in a parse tree.
    ++ This has both type and value information.
    ++ Initially nt holds an approximate type but later this needs
    ++ be matched to a full SPAD type held in spadType.
  KEYS ==> List Record(keya:String,keyb:Symbol,keyc:NNI,keyd:NNI,keye:NNI,keyf:NNI)
    ++ Table of keywords and their precidences. Contains:
    ++ keya:String - name of keyword
    ++ keyb:Symbol - symbolic identifier for keyword
    ++ keyc:NNI - left precidence for binary operations
    ++ keyd:NNI - right precidence for binary operations
    ++ keye:NNI - left precidence for unary operations
    ++ keyf:NNI - right precidence for unary operations
    ++ perhaps this should be hash table?
    ++ can be optimised later if needed

  Exports == with

    spadInterpret:() -> %
      ++ constructor to setup parameters and run interpreter
      ++ inside existing interpreter
    getKeys:(par:%) -> KEYS
      ++ get table of keywords containing operators and their
      ++ precidences
    coerce:(n: %) -> OutputForm
      ++ say bye bye

  Implementation ==> add
  
    import from Tokeniser
    import from Parser
    import from TypeMatcher
    --The function retractIfCan with signature (Union (Integer) failed)$ is 
    --  missing from domain String
    --import from IntegerRetractions(String)

    Rep := Record(_
      op: KEYS,_
      Coerce:SY,_
      compErrorMessageStack:SY,_
      freeVars:SY,_
      mapList:SY,_
      compilingMap:SY,_
      compilingLoop:SY,_
      interpOnly:SY,_
      whereCacheList:SY,_
      timeGlobalName:SY,_
      StreamFrame:SY,_
      declaredMode:SY,_
      localVars:SY,_
      analyzingMapList:SY,_
      lastLineInSEQ:SY,_
      instantCoerceCount:SY,_
      instantCanCoerceCount:SY,_
      instantMmCondCount:SY,_
      defaultFortVar:SY,_
      fortVar:SY,_
      defaultFortVar:SY,_
      minivector:SY,_
      minivectorCode:SY,_
      minivectorNames:SY,_
      domPvar:SY,_
      inRetract:SY_
    )
      ++ parameters (was global parameters)
      ++ I have just set everthing to Symbol for now but will
      ++ set them to the correct high level types when I get
      ++ to implementing code that needs them.

    integerIfCan(s:String):Union(Integer,"failed") ==
      res:Integer := 0
      inp:List(Character):= parts(s)
      for c in inp repeat
        if not digit?(c) then return "failed"
        if c=char("0") then res := res*10
        if c=char("1") then res := res*10 + 1
        if c=char("2") then res := res*10 + 2
        if c=char("3") then res := res*10 + 3
        if c=char("4") then res := res*10 + 4
        if c=char("5") then res := res*10 + 5
        if c=char("6") then res := res*10 + 6
        if c=char("7") then res := res*10 + 7
        if c=char("8") then res := res*10 + 8
        if c=char("9") then res := res*10 + 9
      --print(hconcat([outputForm("integerIfCan "),outputForm(res)])$OutputForm)
      res

    -- if a line starts with ) this indicates a system command
    -- so this will be called
    -- intended to replace ncloopCommand in
    -- int-top.boot
    -- returns true unless we want interpreter loop to end, in which
    -- case we return false.
    processSystemCommand(s:String,param:%,lineNum:NNI):Boolean ==
      words:List(String) := split(s,space())
      empty?(words) => false
      word1:String := first(words)
      empty?(word1) => false
      word1 := lowerCase(word1)
      if substring?("q",word1,2) then return false
      if substring?("se",word1,2) then
        if (#words)<2 then
          ncloopCommand(s,lineNum)$Lisp
          return true
        word2:String := words.2
        word2 := lowerCase(word2)
        if substring?("p",word2,1) then
          if (#words)<5 then
            print(outputForm("processSystemCommand: op and 2 precidence values required")$OutputForm)
            return true
          op:String := words.3
          leftPrec1 := integerIfCan(words.4)@Union(Integer,"failed")
          rightPrec1:= integerIfCan(words.5)@Union(Integer,"failed")
          if leftPrec1 = "failed" then return true
          leftPrec:Integer := leftPrec1::Integer
          if rightPrec1 = "failed" then return true
          rightPrec:Integer := rightPrec1::Integer
          print(hconcat([outputForm("processSystemCommand op="::SY),_
            outputForm(op),_
            outputForm(" left="::SY),outputForm(leftPrec),_
            outputForm(" right="::SY),outputForm(rightPrec)])$OutputForm)
          keys:KEYS := getKeys(param)
          for key in keys for index in 1..#keys repeat
            if op = key.keya then
              key2:Record(keya:String,keyb:Symbol,keyc:NNI,keyd:NNI,keye:NNI,keyf:NNI)
              key2 := [key.keya,key.keyb,leftPrec::NNI,rightPrec::NNI,key.keye,key.keyf]
              setelt!(keys,index,key2)
              return true
          print(outputForm("processSystemCommand op not found"))
          return true
        ncloopCommand(s,lineNum)$Lisp
        return true
      if substring?("g",word1,2) then
        if (#words)<2 then
          ncloopCommand(s,lineNum)$Lisp
          return true
        word2:String := words.2
        word2 := lowerCase(word2)
        if substring?("p",word2,1) then
          if (#words)<3 then
            print(outputForm("processSystemCommand: op required")$OutputForm)
            return true
          op:String := words.3
          keys:KEYS := getKeys(param)
          for key in keys for index in 1..#keys repeat
            if op = key.keya then
              print(hconcat([outputForm("processSystemCommand op="::SY),_
                outputForm(op),_
                outputForm(" left="::SY),outputForm(key.keyc),_
                outputForm(" right="::SY),outputForm(key.keyd)])$OutputForm)
              return true
          print(outputForm("processSystemCommand op not found"))
          return true
        ncloopCommand(s,lineNum)$Lisp
        return true
      ncloopCommand(s,lineNum)$Lisp
      true

    -- if a line is not a system command then this will be called
    -- intended to replace intloopProcessString in
    -- int-top.boot
    processMath(s:String,param:%,lineNum:NNI):Boolean ==
      --c := intloopProcessString(s,lineNum)$Lisp
--      b := incString(s)$Lisp
--      mathprint("token:")$Lisp
--      print(b::OutputForm)
--      c := lineoftoks(b)$Lisp
--      mathprint("lineoftoks:")$Lisp
--      print(c::OutputForm)
--      d := parseFromString(s)$Lisp
--      mathprint("parse:")$Lisp
--      print(d::OutputForm)
      tokList := spadTokenise(s,param pretend Interpret)
      if hasError?(tokList) then
        mathprint("tokeniser:")$Lisp
        print(tokList::OutputForm)
        return true
      mathprint("parser:")$Lisp
      parseTree := spadParse(tokList,param pretend Interpret)
      if hasError?(parseTree,0) then
        mathprint("has error")$Lisp
        print((parseTree pretend Tree(NODE))::OutputForm)
        return true
      print((parseTree pretend Tree(NODE))::OutputForm)
      mathprint("type match:")$Lisp
      typTree := typeMatch(parseTree,param pretend Interpret)
      print((typTree pretend Tree(NODE))::OutputForm)
      true

    -- check for system commands 
    -- check for continuation to line
    -- then interpret.
    -- intended to replace intLoopReadConsole in
    -- int-top.boot
    processString(s:String,param:%,lineNum:NNI):Boolean ==
      if s=empty()$String then return true
      if s="" then  return true
      if position(")",s,1) = 1 then
        return processSystemCommand(s,param,lineNum)
      processMath(s,param,lineNum)

    -- get table of keywords containing operators and their
    -- precidences
    getKeys(par:%):KEYS == par.op

    -- constructor to setup parameters and run interpreter
    -- inside existing interpreter
    spadInterpret():% ==
      -- precidences from nud table
      -- from s-parser.boot
      keys:KEYS := [_
           ["add","add"::SY,400,120,900,120],_
           ["and","and"::SY,250,251,0,0],_
           ["break","break"::SY,0,0,0,0],_
           ["by","by"::SY,0,0,0,0],_
           ["case","case"::SY,400,400,0,0],_
           ["catch","catch"::SY,0,0,0,114],_
           ["default","DEFAULT"::SY,0,0,0,0],_
           ["define","DEFN"::SY,0,0,0,0],_
           ["do","DO"::SY,0,0,0,0],_
           ["else","else"::SY,0,0,0,114], _
           ["exquo","exquo"::SY,800,801,0,0], _
           ["export","EXPORT"::SY,0,0,0,0],_
           ["finally","finally"::SY,0,0,0,114], _
           ["for","for"::SY,0,0,130,350], _
           ["free","FREE"::SY,0,0,0,0],_
           ["from","from"::SY,0,0,0,0], _
           ["generate","generate"::SY,0,0,0,0], _
           ["goto","goto"::SY,0,0,0,0], _
           ["has","has"::SY,400,400,400,400], _
           ["if","if"::SY,0,0,130,0], _
           ["import","import"::SY,0,0,120,0], _
           ["in","in"::SY,400,400,0,0], _
           ["inline","INLINE"::SY,0,0,0,0],_
           ["is","is"::SY,400,400,0,0], _
           ["isnt","isnt"::SY,400,400,0,0], _
           ["iterate","ITERATE"::SY,0,0,0,0],_
           ["local","local"::SY,0,0,0,0], _
           ["macro","MACRO"::SY,0,0,0,0],_
           ["mod","MOD"::SY,0,0,0,0],_
           ["not","not"::SY,0,0,260,259], _
           ["or","or"::SY,200,201,0,0], _
           ["pretend","pretend"::SY,995,996,0,0], _
           ["quo","quo"::SY,800,801,0,0], _
           ["rem","rem"::SY,800,801,0,0], _
           ["repeat","repeat"::SY,0,0,130,190],_
           ["return","return"::SY,0,0,202,201],_
           ["rule","RULE"::SY,0,0,0,0],_
           ["then","then"::SY,0,0,0,114],_
           ["try","try"::SY,0,0,130,0], _
           ["until","until"::SY,0,0,130,190], _
           ["where","where"::SY,121,104,0,0], _
           ["while","while"::SY,0,0,130,190],_
           ["with","with"::SY,2000,400,1000,300], _
           ["yield","yield"::SY,0,0,0,0], _
           ["|","BAR"::SY,108,111,0,190],_
           [".","DOT"::SY,0,0,0,0],_
           ["::","COERCE"::SY,996,997,0,0],_
           [":","COLON"::SY,996,997,194,195],_
           [":-","COLONDASH"::SY,0,0,0,0],_
           ["!","BANG"::SY,1002,1001,0,0],_
           ["@","AT"::SY,996,997,0,0],_
           ["@@","ATAT"::SY,0,0,0,0],_
           [",","COMMA"::SY,110,111,0,0],_
           [";","SEMICOLON"::SY,81,82,0,0],_
           ["**","POWER"::SY,901,900,0,0],_
           ["*","TIMES"::SY,800,801,0,0],_
           ["+","PLUS"::SY,700,701,0,0],_
           ["-","MINUS"::SY,700,701,701,700],_
           ["<","LT"::SY,400,400,0,0],_
           [">","GT"::SY,400,400,0,0],_
           ["<=","LE"::SY,400,400,0,0],_
           [">=","GE"::SY,400,400,0,0],_
           ["=", "EQUAL"::SY,400,400,400,700],_
           ["~=","NOTEQUAL"::SY,400,400,0,0],_
           ["^=","CARATEQUAL"::SY,400,400,0,0],_
           ["~","TILDE"::SY,0,0,260,259],_
           ["^","CARAT"::SY,901,900,0,0],_
           ["..","SEG"::SY,401,699,0,0],_
           ["#","#"::SY,0,0,999,998],_
           ["#1","#1"::SY,0,0,0,0],_
           ["&","AMPERSAND"::SY,0,0,0,0],_
           ["$","$"::SY,0,0,0,0],_
           ["/","SLASH"::SY,800,801,0,0],_
           ["\","BACKSLASH"::SY,0,0,0,0],_
           ["//","SLASHSLASH"::SY,0,0,0,0],_
           ["\\","BACKSLASHBACKSLASH"::SY,0,0,0,0],_
           ["/\","SLASHBACKSLASH"::SY,250,251,0,0],_
           ["\/","BACKSLASHSLASH"::SY,200,201,0,0],_
           ["=>","EXIT"::SY,123,103,0,0],_
           [":=","BECOMES"::SY,125,124,0,0],_
           ["==","DEF"::SY,122,121,0,0],_
           ["==>","MDEF"::SY,122,121,0,0],_
           ["->","ARROW"::SY,1002,1001,1001,1002],_
           ["<-","LARROW"::SY,1001,1002,0,0],_
           ["+->","GIVES"::SY,995,112,0,0],_
           ["(","OParen"::SY,0,0,0,0],_
           [")","CParen"::SY,0,0,0,0],_
           ["(|","(|"::SY,0,0,0,0],_
           ["|)","|)"::SY,0,0,0,0],_
           ["[","["::SY,0,0,0,0],_
           ["]","]"::SY,0,0,0,0],_
           ["[__]","[]"::SY,0,0,0,0],_
           ["{","{"::SY,0,0,0,0],_
           ["}","}"::SY,0,0,0,0],_
           ["{__}","{}"::SY,0,0,0,0],_
           ["[|","[|"::SY,0,0,0,0],_
           ["|]","|]"::SY,0,0,0,0],_
           ["[|__|]","[||]"::SY,0,0,0,0],_
           ["{|","{|"::SY,0,0,0,0],_
           ["|}","|}"::SY,0,0,0,0],_
           ["{|__|}","{||}"::SY,0,0,0,0],_
           ["<<","OANGLE"::SY,400,400,0,0],_
           [">>","CANGLE"::SY,400,400,0,0],_
           ["'","'"::SY,0,0,999,999],_
           ["`","BACKQUOTE"::SY,0,0,0,0]]
      -- setup global parameters 
      param:% := [keys,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X]
      keepGoing:Boolean := true
      lineNum:NNI := 1
      while keepGoing repeat
        -- display prompt without carrage return
        -- I have added m so that I know this interpreter is running
        PRINC(concat(["(m",string(lineNum),") -> "])$String)$Lisp
        FORCE_-OUTPUT()$Lisp
        -- read a line from stdin to a string
        s := (read_-line(_*STANDARD_-INPUT_*$Lisp)$Lisp)@String
        --s:String := string(a) --a::String
        keepGoing := processString(s,param,lineNum)
        lineNum := lineNum + 1
      param

    -- say bye bye
    coerce(n: %):OutputForm ==
      outputForm("interpreter stopped"::SY)

@
